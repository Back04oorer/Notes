### Data Analysis in the Enterprise
#### Traditional Analytics
- Data Warehousing
	- Consolidate data from many databases in one large repository.
	- Loading, periodic synchronization of replicas.
	-  Semantic integration.
- OLAP (Online Analytical Processing):
	- Complex SQL queries and views.
	- Interactive and “online” queries based on spreadsheet-style operations and “multidimensional” view of data.
#### OLTP vs OLAP
- **OLTP:** Online Transaction Processing
	- Maintains a database that is an accurate model of some real-world enterprise. Supports day-to-day operations. Characteristics:
		- Short simple transactions
		- Transactions are well-known (parameters may vary)
		- Relatively frequent updates to data
		- Each transaction accesses only a small fraction of the database
		- Each transaction typically needs data about the current state of the domain (not the history over a long time)
- **OLAP:** Online Analytic Processing
	- Uses information in database to guide strategic decisions. Characteristics:
		- Complex queries
		- Infrequent updates (typically only on periodic refresh of data)
		- A single query may access a large fraction of the database
		- Data need not be perfectly up-to-date for query to be useful
		- Transactions often need a lot of historic data
#### Data Warehouse
OLAP (and data mining) is often done on a database which is stored on a special server called data warehouse:
- Used in support of management decision-making processes
- Integrated data spanning long time periods, often augmented with summary information.
- Can accommodate the huge amount of data generated by multiple OLTP systems
- Interactive response times are expected for complex queries
- Read-only, except for brief periods when contents are refreshed
- Allow OLAP queries to be run off-line so as not to impact the performance of OLTP
#### Why separate servers
- The system internals (hardware and software) that work well for OLTP often don’t perform well for OLAP, and vice versa
- The updates in OLTP often cause delays to the long- running report calculations of OLAP, and vice versa
- So, it makes sense to operate
	- one system optimized for OLAP, where OLAP runs
	- one system optimized for OLTP, where OLTP runs
- Recent research tries to find a system design that can support both efficiently (called HTAP “Hybrid transaction and analytics processing”)
![[Pasted image 20241111125513.png]]
#### Issues in Data Warehousing
- **Semantic Integration:** When getting data from multiple sources, must eliminate mismatches, e.g., different currencies, schemas.
- **Heterogeneous Sources:** Must access data from a variety of source formats and repositories.
- **Load, Refresh, Purge:** Must load data, periodically refresh it, and purge too- old data.
- **Metadata Management**: Must keep track of source, loading time, and other information for all data in the warehouse
#### ETL Process
- Typical operational data is:
	- Transient – not historical
	- Restricted in scope – not comprehensive
	- Sometimes poor quality – inconsistencies and errors
- ETL (Extract-Transform-Load) Process
	- Capture/Extract
	- Data Cleaning
	- Load
- After ETL, data should be
	- Detailed – not summarized yet
	- Historical – periodic
	- Comprehensive – enterprise-wide perspective
	- In the right, uniform format of the data warehouse
	- Quality controlled – accurate with full integrity
![[Pasted image 20241111143640.png]]
#### Transform
- The Transform step must be automated, and there are many complex aspects
- Adjust structure for the warehouse target schema
	- May require joining source tables, splitting source fields
- Adjust values for the warehouse target schema
	- May involve calculations (eg deg C to deg F), lookup in translation tables (eg use currency exchange rates); also data cleaning to fix mistakes in source data
- ETL Tools often offer proprietary language for programming the Transform step
#### Metadata
As with other databases, a warehouse must include a metadata repository
- Information about physical and logical organization of data
- Also, keep information about the source of each data item and the dates on which it was loaded and refreshed
#### Incremental Updates
- The large volume of data in a data warehouse makes loading and updating a significant task
- For efficiency, updating is usually incremental
- Incremental updates might result in the database being in an inconsistent state
	- Usually not important because queries involve only statistical summaries of data, which are not greatly affected by such inconsistencies
#### Fact tables
Relational OLAP applications are based on a <mark style="background: #FFB8EBA6;">fact table</mark>
The table can be viewed as multidimensional
![[Pasted image 20241111145853.png]]
#### Data Cube
Fact tables can be displayed as an N-dimensional data cube (3- dimensional in our example)
![[Pasted image 20241111145926.png]]
#### Dimension Tables
The dimensions of the fact table are further described with dimension tables
- Supermarket Example: Fact table 
	- Sales (Market_id, Product_Id, Time_Id, Sales_Amt)
- Dimension Tables:
	- Market (Market_Id, City, State, Region)
	- Product (Product_Id, Name, Category, Price) 
	- Time (Time_Id, Week, Month, Quarter, Year)
#### Star Schema
The fact and dimension relations can be displayed in an E-R diagram, which looks like a star and is called a star schema
![[Pasted image 20241111150107.png]]
#### Aggregation
-  Many OLAP queries involve aggregation of the data in the fact table
- For example, to find the total sales (over time) of each product in each market, we might use
```SQL
SELECT S.Market_Id, S.Product_Id, SUM (S.Sales_Amt) 
FROM Sales S 
GROUP BY S.Market_Id, S.Product_Id
```
#### Drilling Down
 - Drilling down on market: from Country to State
```SQL
Sales (Market_Id, Product_Id, Time_Id, Sales_Amt) 
Market (Market_Id, City, State, Country)
```
- This is often called “dicing” – it divides each cell into several smaller ones, which can reveal differences between
```SQL
SELECT S.Product_Id, M.Country, SUM(S.Sales_Amt)
FROM Sales S, Market M
WHERE M.Market_Id = S.Market_Id
GROUP BY S.Product_Id, M.Country

SELECT S.Product_Id, M.Country, SUM(S.Sales_Amt)
FROM Sales S, Market M
WHERE M.Market_Id = S.Market_Id
GROUP BY S.Product_Id, M.Country
```
#### Rolling Up
- Rolling up on market, from State to Country
```SQL
SELECT S.Product_Id, M.State, SUM(S.Sales_Amt)
FROM Sales S, Market M
WHERE M.Market_Id = S.Market_Id
GROUP BY S.Product_Id, M.State
```
- Then we can roll up from there tp
```SQL
SELECT T.Product_Id, M.Country, SUM(T.Sales_Amt)
FROM State_Sales T, Market M
WHERE M.State = T.State
GROUP BY T.Product_Id, M.Country
```
#### Pivoting
When we view the data as a multi-dimensional cube and group on a subset of the axes, we are said to be performing a pivot on those axes
- Pivoting on dimensions $D_1,...D_k$ in a data cube $D_1,...,D_k,D_{k+1},..D_n$ means that we use `GROUP BY` $A_1,...A_k$ and aggregate over $A_{K+1},...A_n$ where $A_i$ is an attribute of the dimension $D_i$
```SQL
SELECT S.Product_Id, T.Quarter, SUM(S.Sales_Amt)
FROM Sales S, Time T
WHERE T.Time_Id = S.Time_Id
GROUP BY S.Product_Id, T.Quarter
```
#### Slicing
When we to restrict our query to a particular value for an axis (or several axes), we are performing a slice
- Slicing the data cube in the Time dimension (choosing sales only in week 12) then pivoting to Product_id (aggregating over Market_id)
```SQL
SELECT S.Product_Id, SUM(Sales_Amt)
FROM Sales S, Time T
WHERE T.Time_Id = S.Time_Id AND T.Week = 'Wk-12'
GROUP BY S.Product_Id
```
#### Slicing and Dicing
![[Pasted image 20241111154532.png]]
#### Cube Operator
- The following query returns all the information needed to make the previous products/markets table:
```SQL
SELECT S.Market_Id, S.Product_Id, SUM(S.Sales_Amt)
FROM Sales S
GROUP BY CUBE (S.Market_Id, S.Product_Id)
```
When seen as relational output (not displayed in cube format), the marginals are shown as rows which have NULL for any grouping column that is aggregated over
#### GROUPING SETs
```SQL
SELECT prod_id, cust_id, channel_id, SUM(quantity_sold)
FROM Sales
WHERE cust_id < 3
GROUP BY GROUPING SETS (
    (prod_id),
    (cust_id),
    (cust_id, channel_id)
);
```
Allows to explicitly specify a set of grouping operations which should be performed by a single query – Pro: Less overhead than individual OLAP queries; single scan of fact table only

#### Windowing vs. Grouping
![[Pasted image 20241111155904.png]]



# Relational Algebra

| Operation      | Symbols   | Example                                                    |
| -------------- | --------- | ---------------------------------------------------------- |
| Projection     | $\Pi$     | $\Pi_{name,country}(Student)$                              |
| Selection      | $\sigma$  | $\sigma_{country = 'AUS'}(Student)$                        |
| Cross-product  | $\times$  | $R \times S$                                               |
| Joins          | $\bowtie$ | Student $\bowtie_{family\_name=last\_name}$ Lecturer       |
| Natural Join   | $\bowtie$ | $R \bowtie S$                                              |
| Rename         | $\rho$    | $\rho_{x}(E)$, $\rho_{x(a1 \rightarrow a2)}(E)$            |
| Set Difference | -         | tuples in relation 1, but not in relation 2                |
| Division       | /         | $R/s:= \{<a> \| \forall <b> \in S: \exists <a,b> \in R \}$ |
