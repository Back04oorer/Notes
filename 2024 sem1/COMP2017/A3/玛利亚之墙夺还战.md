这个任务涉及解析 .bpkg 文件，并将其内容加载到 Merkle 树中。以下是有关 .bpkg 文件格式和任务要求的详细中文翻译：

# 要求
### 1.1 包及其文件格式（.bpkg）

在这个程序中，文件由几个异常数据块组成。这些块以特定方式组织，当它们结合时，可以构建并向用户展示文件的全部内容。一个包定义了构建文件内容所需的信息和资源。包通过一个标识符字符串 "ident" 来代表一个唯一的文件。包文件格式是一个文本格式，需要由您的程序解析。包文件格式包含以下字段：

- **ident**：十六进制字符串（最多1024个字符），用于在网络中标识相同的包。
- **filename**：字符串（最多256个字符），用于帮助保存和定位需要更新数据时的文件。
- **size**：uint32_t，指定文件的大小（以字节为单位）。
- **nhashes**：uint32_t，指定预计算的哈希数。哈希数量必须是 $2^{(h-1)}-1$，对应所有非叶子节点的哈希。
- **hashes**：字符串数组 `string[2^(h-1) - 1]`（每个字符串64字符），对应于上述 nhashes 字段中的哈希数。
- **nchunks**：uint32_t，指定块的数量。块的数量必须是 $2^{(h-1)}-1$。
- **chunks**：结构体数组 `struct[2^(h-1)]`，每个块具有以下字段：
    - **hash**：字符串（64字符），对应于数据块的哈希值。
    - **offset**：uint32_t，文件中的偏移量。
    - **size**：uint32_t，块的字节大小。

### 1.2 包加载

此任务的重点是加载 .bpkg 文件并将详细信息存储到 Merkle 树中。完成这个任务后，您应该能够执行 pkgchk.c 文件中的 `bpkg_get_all_hashes` 和 `bpkg_get_all_chunk_hashes_from_hash` 函数，而无需对数据文件进行 IO 操作。

### 1.3 什么是 Merkle 树？

Merkle 树是二叉树的一种变体，其中每个节点包含一个哈希值。叶子节点的哈希值对应于数据块的哈希值，其他所有非叶子节点的哈希值通过组合其子节点的哈希值并对该组合值进行哈希处理来获得。Merkle 树通常是一个完美的或完全的二叉树，但也可以是一个完整的二叉树。这种结构使得可以有效地验证数据块和文件的完整性。



### <mark style="background: #FF5582A6;">Tip</mark> how to build Merkle tree?
#### 步骤1：解析 `.bpkg` 文件

首先，你需要从 `.bpkg` 文件中提取所有相关数据，包括：

- 数据块（data chunks）
- 每个数据块的偏移量和大小
- 所有非叶子节点的预存储哈希值（`expected_hash`）

#### 步骤2：构建叶子节点

对于每个数据块，计算其哈希值，这将成为 Merkle 树中叶子节点的 `computed_hash`。叶子节点通常直接对应文件的某个具体部分。

#### 步骤3：逐级构建非叶子节点

从叶子节点开始，逐步向上：

- 将两个子节点的 `computed_hash` 值连接起来（通常是左子节点后接右子节点）。
- 对这个连接后的字符串应用哈希函数，生成该节点的 `computed_hash`。
- 这个过程重复进行，直到计算出根节点的 `computed_hash`。

#### 步骤4：验证数据完整性

最后，将根节点的 `computed_hash` 与文件中存储的根节点 `expected_hash` 进行比较：

- 如果两者相匹配，则说明数据完整无误。
- 如果不匹配，则表明数据在某处被篡改或在传输过程中出现错误。
### 1.4 更正、变体和备注

- **实现方式**：并不一定要求 Merkle 树是一个完全或完整的二叉树。理论上，你可以实现一个具有多于两个子节点的 Merkle 树，或者不是所有叶子节点都位于同一层级。然而，我们做出这样的假设是为了简化数据结构的实现。
- **相同的块，不同的位置**：通过实验，你可能发现如果有包含相同数据的块，你的实现需要假设这种情况不会发生，或者包含必要的数据来区分它们。请参考 REQ 数据包，特别是偏移量部分，以帮助解决搜索问题。你可以像前一节的图示那样，有一个位字段键与此相伴。
- **数据过剩**：为了帮助实现这一数据结构，并确保在不完整状态下其他部分不受限制，提供的文件包含了超出需求的数据。
- **使用十六进制哈希或字节哈希**：员工实现使用的是十六进制哈希，而计算字节哈希虽然不是错误的，但会与测试用例产生不同的结果。请确保你的实现符合这一要求。

### 1.5 检查清单

- **解析有效的 .bpkg 文件**，确保你能读取它们的每一个字段。
- **从解析后的 bpkg 文件构建 Merkle 树**。
- **实现所有 pkgchk.c 中的函数**。
- **编译和运行**，使用 `make pkgchk.o` 编译，这对测试用例是必需的。
- **你可以自由修改 Makefile**，以引用你在构建目标中将使用的 c 文件。
- **运行和编译 make pkgchecker**，并与 pkgmain.c 一起编译，以本地测试你的程序。





# Notes
## 高性能merkle树的决策
#### 1. 理解 `.bpkg` 文件结构

首先，你需要完全理解 `.bpkg` 文件的结构，包括如何从文件中解析出数据块（chunks）和哈希。这些数据块将成为 Merkle 树的叶子节点，而非叶子节点的哈希将由这些叶子节点的哈希计算得出。

#### 2. 数据块的读取和哈希计算

- **并行读取**：使用多线程或异步 I/O 来并行读取数据块。这可以显著减少大文件读取的时间。
- **并行哈希**：每个线程可以独立计算一个或多个数据块的哈希值。这样做可以利用多核处理器，减少哈希计算的总时间。

#### 3. 构建树结构

- **自底向上构建**：从叶子节点开始，逐步向上计算父节点的哈希值。每个父节点的哈希是其两个子节点的哈希值经过特定哈希函数处理后得到的。
- **并行树构建**：在可能的情况下，可以并行地计算多个父节点的哈希值。例如，可以将树的不同部分分配给不同的线程进行处理。

#### 4. 优化存储结构

- **内存管理**：合理管理内存，尤其是在处理大型数据时，确保数据结构的内存效率和访问速度。
- **数据结构选择**：选择适合快速访问和修改的数据结构来存储树节点，如平衡二叉树结构或哈希表。

#### 5. 测试和验证

- **完整性验证**：确保每个节点的哈希正确反映其子节点的哈希。
- **性能测试**：通过基准测试来评估不同并行策略的效果，调整线程数量和任务分配以获得最佳性能。

#### 6. 报告和分析

- **性能分析**：分析并记录不同配置下的性能表现，包括处理时间和资源利用率。
- **结果可视化**：制作图表来显示不同线程数量对性能的影响，以及优化前后的对比。