这个任务涉及解析 .bpkg 文件，并将其内容加载到 Merkle 树中。以下是有关 .bpkg 文件格式和任务要求的详细中文翻译：

# 第一部分
### 1.1 包及其文件格式（.bpkg）

在这个程序中，文件由几个异常数据块组成。这些块以特定方式组织，当它们结合时，可以构建并向用户展示文件的全部内容。一个包定义了构建文件内容所需的信息和资源。包通过一个标识符字符串 "ident" 来代表一个唯一的文件。包文件格式是一个文本格式，需要由您的程序解析。包文件格式包含以下字段：

- **ident**：十六进制字符串（最多1024个字符），用于在网络中标识相同的包。
- **filename**：字符串（最多256个字符），用于帮助保存和定位需要更新数据时的文件。
- **size**：uint32_t，指定文件的大小（以字节为单位）。
- **nhashes**：uint32_t，指定预计算的哈希数。哈希数量必须是 $2^{(h-1)}-1$，对应所有非叶子节点的哈希。
- **hashes**：字符串数组 `string[2^(h-1) - 1]`（每个字符串64字符），对应于上述 nhashes 字段中的哈希数。
- **nchunks**：uint32_t，指定块的数量。块的数量必须是 $2^{(h-1)}-1$。
- **chunks**：结构体数组 `struct[2^(h-1)]`，每个块具有以下字段：
    - **hash**：字符串（64字符），对应于数据块的哈希值。
    - **offset**：uint32_t，文件中的偏移量。
    - **size**：uint32_t，块的字节大小。

### 1.2 包加载

此任务的重点是加载 .bpkg 文件并将详细信息存储到 Merkle 树中。完成这个任务后，您应该能够执行 pkgchk.c 文件中的 `bpkg_get_all_hashes` 和 `bpkg_get_all_chunk_hashes_from_hash` 函数，而无需对数据文件进行 IO 操作。

### 1.3 什么是 Merkle 树？

Merkle 树是二叉树的一种变体，其中每个节点包含一个哈希值。叶子节点的哈希值对应于数据块的哈希值，其他所有非叶子节点的哈希值通过组合其子节点的哈希值并对该组合值进行哈希处理来获得。Merkle 树通常是一个完美的或完全的二叉树，但也可以是一个完整的二叉树。这种结构使得可以有效地验证数据块和文件的完整性。



### <mark style="background: #FF5582A6;">Tip</mark> how to build Merkle tree?
#### 步骤1：解析 `.bpkg` 文件

首先，你需要从 `.bpkg` 文件中提取所有相关数据，包括：

- 数据块（data chunks）
- 每个数据块的偏移量和大小
- 所有非叶子节点的预存储哈希值（`expected_hash`）

#### 步骤2：构建叶子节点

对于每个数据块，计算其哈希值，这将成为 Merkle 树中叶子节点的 `computed_hash`。叶子节点通常直接对应文件的某个具体部分。

#### 步骤3：逐级构建非叶子节点

从叶子节点开始，逐步向上：

- 将两个子节点的 `computed_hash` 值连接起来（通常是左子节点后接右子节点）。
- 对这个连接后的字符串应用哈希函数，生成该节点的 `computed_hash`。
- 这个过程重复进行，直到计算出根节点的 `computed_hash`。

#### 步骤4：验证数据完整性

最后，将根节点的 `computed_hash` 与文件中存储的根节点 `expected_hash` 进行比较：

- 如果两者相匹配，则说明数据完整无误。
- 如果不匹配，则表明数据在某处被篡改或在传输过程中出现错误。
### 1.4 更正、变体和备注

- **实现方式**：并不一定要求 Merkle 树是一个完全或完整的二叉树。理论上，你可以实现一个具有多于两个子节点的 Merkle 树，或者不是所有叶子节点都位于同一层级。然而，我们做出这样的假设是为了简化数据结构的实现。
- **相同的块，不同的位置**：通过实验，你可能发现如果有包含相同数据的块，你的实现需要假设这种情况不会发生，或者包含必要的数据来区分它们。请参考 REQ 数据包，特别是偏移量部分，以帮助解决搜索问题。你可以像前一节的图示那样，有一个位字段键与此相伴。
- **数据过剩**：为了帮助实现这一数据结构，并确保在不完整状态下其他部分不受限制，提供的文件包含了超出需求的数据。
- **使用十六进制哈希或字节哈希**：员工实现使用的是十六进制哈希，而计算字节哈希虽然不是错误的，但会与测试用例产生不同的结果。请确保你的实现符合这一要求。

### 1.5 检查清单

- **解析有效的 .bpkg 文件**，确保你能读取它们的每一个字段。
- **从解析后的 bpkg 文件构建 Merkle 树**。
- **实现所有 pkgchk.c 中的函数**。
- **编译和运行**，使用 `make pkgchk.o` 编译，这对测试用例是必需的。
- **你可以自由修改 Makefile**，以引用你在构建目标中将使用的 c 文件。
- **运行和编译 make pkgchecker**，并与 pkgmain.c 一起编译，以本地测试你的程序。

# Notes
## 高性能merkle树的决策
#### 1. 理解 `.bpkg` 文件结构

首先，你需要完全理解 `.bpkg` 文件的结构，包括如何从文件中解析出数据块（chunks）和哈希。这些数据块将成为 Merkle 树的叶子节点，而非叶子节点的哈希将由这些叶子节点的哈希计算得出。
#### 2. 数据块的读取和哈希计算

- **并行读取**：使用多线程或异步 I/O 来并行读取数据块。这可以显著减少大文件读取的时间。
- **并行哈希**：每个线程可以独立计算一个或多个数据块的哈希值。这样做可以利用多核处理器，减少哈希计算的总时间。

#### 3. 构建树结构

- **自底向上构建**：从叶子节点开始，逐步向上计算父节点的哈希值。每个父节点的哈希是其两个子节点的哈希值经过特定哈希函数处理后得到的。
- **并行树构建**：在可能的情况下，可以并行地计算多个父节点的哈希值。例如，可以将树的不同部分分配给不同的线程进行处理。

#### 4. 优化存储结构

- **内存管理**：合理管理内存，尤其是在处理大型数据时，确保数据结构的内存效率和访问速度。
- **数据结构选择**：选择适合快速访问和修改的数据结构来存储树节点，如平衡二叉树结构或哈希表。

#### 5. 测试和验证

- **完整性验证**：确保每个节点的哈希正确反映其子节点的哈希。
- **性能测试**：通过基准测试来评估不同并行策略的效果，调整线程数量和任务分配以获得最佳性能。

#### 6. 报告和分析

- **性能分析**：分析并记录不同配置下的性能表现，包括处理时间和资源利用率。
- **结果可视化**：制作图表来显示不同线程数量对性能的影响，以及优化前后的对比。

# 第二部分：配置、网络和程序

你现在需要编写一个程序来实现 P2P 文件传输。程序需要完成以下任务：

- **加载配置文件**：程序需要维护一个存储目录路径。
- **遵守网络协议**：与网络中的其他节点通信。
- **实现命令**：包括连接、断开、检索节点信息、处理包的加载与移除，从其他节点检索数据块。

虽然构建默克尔树（Merkle tree）并不是开始或完成这部分的必需条件，但你需要能够加载 `.bpkg` 文件，检索其标识符、文件名、大小、数据块数量及数据块本身。

### 提供的文件

- `src/peer.c`：编写节点管理代码。
- `src/package.c`：编写包管理逻辑。
- `src/config.c`：编写配置逻辑。
- `src/btide.c`：包含主函数，程序的起点。

你可以根据需要更改 `src` 文件夹的内容，但 Makefile 仍需能够构建所需的目标。确保程序能通过 `make btide` 命令编译，这应该会生成一个可执行文件。

### 配置文件

程序将通过命令行参数传递配置文件，例如：`./btide config.cfg`。

配置文件包括：

- `directory`（字符串）：存储 `.bpkg` 文件及其映射文件的本地路径。如果目录不存在，程序应尝试创建它。如果无法创建目录或目录是文件，则程序应以退出代码 3 退出。
- `max_peers`（整数）：程序可连接的最大节点数，有效范围为 [1, 2048]。如果设置了无效的 `max_peers` 值，程序应以退出代码 4 退出。
- `port`（uint16_t）：客户端监听的端口，有效端口范围为 (1024, 65535]。如果设置了无效的端口值，程序应以退出代码 5 退出。

配置文件示例：
```C
directory:downloads 
max_peers:128 
port:9000
```
  
如果字段的值不满足以上条件，程序将采取相应的行动。如果配置文件缺少任何字段，应该拒绝这个配置。



### 网络协议

您的程序可以作为网络参与者的服务器和客户端。您需要能够形成监听套接字以接受来电连接，同时也能够建立新的连接。网络协议将使用“TCP/IP”数据包来建立连接。您的程序应使用以下包结构：

```C
union btide_payload {
    uint8_t data[PAYLOAD_MAX];
};

struct btide_packet {
    uint16_t msg_code;
    uint16_t error;
    union btide_payload pl;
};
```

以下是可设置的 `msg_code` 值：

- `PKT_MSG_ACK` 0x0c
- `PKT_MSG_ACP` 0x02
- `PKT_MSG_DSN` 0x03
- `PKT_MSG_REQ` 0x06
- `PKT_MSG_RES` 0x07
- `PKT_MSG_PNG` 0xFF
- `PKT_MSG_POG` 0x00

您的程序可以发送和接收以下类型的数据包及其字节码值。所有包应为 4096 字节，其有效载荷数据（如果不为空）应按以下指定的顺序排列，因为测试系统期望数据以此格式提供。不需要在不同有效载荷参数之间填充。

- `ACP` (0x02)，当节点连接到您的程序时，您需要确认您已接受连接，以便它可以确认将其添加到自己的节点列表中。如果您的程序连接到节点，您应该等待返回 ACP 消息，然后才将该节点添加到您自己的节点列表中。如果节点没有响应，您的程序可以中断连接。
- `ACK` (0x0c)，当您的程序在连接后接收到 ACP 包时，您将发送带有 ACK 的消息。这只是简单地确认您已收到消息。
- `DSN` (0x03)，当一个节点想要与另一个节点断开连接时，它将向该节点发送消息，告知它将断开连接。发起消息的节点将关闭其套接字并结束连接。您的程序应该能够检测到由可能未发送 DSN 的节点引起的关闭。
- `REQ` (0x06)，此包被发送到节点以请求特定数据块的数据。请求包将发送 `<identifier>` (1024 字节)，`<chunk hash>` (64 字节) 和 `<offset>` (4 字节，uint32_t) 给另一个节点，期望节点会回传 `<data len>` 的数据。包中的顺序依次是：file_offset, data_len, chunk_hash 和 identifier。
- `RES` (0x07)，此包被发送到 REQ 包的发起者，它将包含：`<identifier>` (1024 字节)，`<chunk hash>` (64 字节)，`<offset>` (4 字节，uint32_t)，`<data len>` (2 字节，uint16_t) 以及最重要的 `<data>` (最大 2998 字节)。包中的顺序依次是：file_offset, data, data_len, chunk_hash 和 identifier。响应包将从数据块中发送数据给请求者，由于文件 `<data len>` 组件可能不符合 REQ 请求包中的 `<req len>` 组件，节点需要发送多个 RES 包以满足请求的数据长度。这是 REQ-RES 流程的正常部分。`<offset>` 指的是将 `<data>` 写入的数据块的偏移量。
- `PNG` (0xFF)，此包被发送出去的目的是检查节点是否仍然在线。通常这通常会定期发送，但在此实现中，我们会在调
- 用 PEERS 命令时发送它。这个特定包不需要错误处理。
- `POG` (0x00)，这是一个对 PNG (0xFF) 消息的回应消息。

这些都是定义在你的程序中用于节点之间通信的不同类型的数据包及其用途。在一个 P2P (点对点) 网络中，节点之间需要交换这些数据包以进行各种网络操作，如建立连接、请求数据、响应请求等。下面分别解释每种数据包的具体用途：

- **ACP (0x02)**：当一个节点尝试连接到你的程序时，如果你的程序接受了这个连接，你的程序会发送一个 ACP 数据包作为响应。这个包是一个“接受连接”确认，用于告诉对方节点连接已被接受。如果你的程序是发起连接的一方，接收到对方的 ACP 包后，你才会将对方节点添加到你的节点列表中。如果没有收到响应，你的程序应中断该连接。
    
- **ACK (0x0c)**：这是一个“确认”包，用于响应接收到的ACP包。当你的程序连接到另一个节点并收到一个 ACP 包后，你的程序将发送一个 ACK 包来简单确认你已接收到 ACP 消息。
    
- **DSN (0x03)**：当一个节点想要与另一个节点断开连接时，它会发送一个 DSN（断开连接通知）包。收到这个包的节点应该关闭与发起节点的连接。此外，如果检测到某节点异常断开（即没有发送DSN包），你的程序也应能处理这种情况。
    
- **REQ (0x06)**：这是一个“请求数据”包，当你的程序需要从另一个节点获取特定数据块时会发送此包。它包含了数据块的标识符、哈希值和偏移量，请求对方节点发送特定长度的数据回来。
    
- **RES (0x07)**：这是对 REQ 包的响应，它包含了请求的数据块信息和数据本身。由于请求的数据长度可能超过单个包的容量，所以可能需要多个 RES 包来满足一个 REQ 的数据请求。
    
- **PNG (0xFF)**：这是一个“ping”包，用于检查一个节点是否仍然在线。这通常在需要确认节点活跃状态时发送，例如在执行与节点列表相关的操作时。
    
- **POG (0x00)**：这是对 PNG 包的响应，即“pong”包，用于回应 PNG 包，确认节点仍然活跃。


在使用多线程解决方案（通常是每个线程一个连接的解决方案）中，特别是可能不知道连接已经终止的情况下，可能会引发 SIGPIPE 信号。确保您的程序处理这个信号，并在出现问题时检测您的套接字错误。所有包都是固定的 4096 字节包。这导致程序中的包处理代码简单化。

  

### 命令

- **CONNECT ip:port**  
    尝试连接到网络上的一个节点。成功连接后输出“Connection established with peer”，失败则输出“Unable to connect to request peer”，如果已连接输出“Already connected to peer”，如果缺少 IP 或端口参数则输出“Missing address and port argument”。
    
- **DISCONNECT ip:port**  
    断开与一个节点的连接并从节点列表中移除。成功断开连接后输出“Disconnected from peer”，如果节点不存在输出“Unknown peer, not connected”，如果缺少 IP 或端口参数则输出“Missing address and port argument”。
    
- **ADDPACKAGE <file>**  
    添加一个包来管理。如果文件参数缺失输出“Missing file argument”，文件不存在或无权限使用时输出“Cannot open file”，文件不是有效的 bpkg 文件时输出“Unable to parse bpkg file”。
    
- **REMPACKAGE <ident, 20 char matching>**  
    移除程序正在管理的一个包。如果 ident 参数缺失输出“Missing identifier argument, please specify whole 1024 character or at least 20 characters”，如果 ident 与管理的包不匹配输出“Identifier provided does not match managed packages”。成功移除包时输出“Package has been removed”。
    
- **PACKAGES**  
    报告加载的包的状态。没有管理任何包时输出“No packages managed”，管理一个或多个包时按照以下格式输出：例如“1. 0c4d036a2161aa6525743d44725e6212, song5.mp3 : INCOMPLETE”。
    
- **PEERS**  
    列出所有已连接的节点。还将触发发送 PNG 数据包到所有已连接的节点。没有连接到任何节点时输出“Not connected to any peers”，连接到一个或多个节点时按以下格式输出：例如“Connected to: 1. 192.168.1.1:9001”。
    
- **FETCH ip:port <identifier> <hash> (<offset>)**  
    根据给定的哈希请求相关的数据块。如果提供的参数不足则输出“Missing arguments from command”，节点不在列表中时输出“Unable to request chunk, peer not in list”，包不在管理列表中时输出“Unable to request chunk, package is not managed”，哈希不属于包时输出“Unable to request chunk, chunk hash does not belong to package”。
    
- **QUIT**  
    程序退出，此命令不应输出任何错误信息。
    

如果输入的命令错误，程序将输出“Invalid Input”。