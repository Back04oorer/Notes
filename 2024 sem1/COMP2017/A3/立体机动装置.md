

# Helpful commands

**test chk/pkgchk.c independently**
```SHELL
make pkgchk.o
make merkletree.o
make sha256.o

gcc -o myprogram pkgchk.o merkletree.o sha256.o -fsanitize=address


gcc -c src/chk/pkgchk.c -Iinclude -Iinclude/tree -Iinclude/chk -Iinclude/crypt -Wall -std=c2x -g -o pkgchk.o

gcc -c src/tree/merkletree.c -Iinclude -Iinclude/tree -Iinclude/chk -Iinclude/crypt -Wall -std=c2x -g -o merkletree.o

gcc -c src/crypt/sha256.c -Iinclude -Iinclude/tree -Iinclude/chk -Iinclude/crypt -Wall -std=c2x -g -o sha256.o

gcc pkgchk.o merkletree.o sha256.o -lm -lpthread -o myprogram

valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./myprogram



```



# Ed
## pkgchk.c

```C

bpkg_get_all_chunk_hashes_from_hash
bpkg_get_all_hashes 
- #

```


# 

```PYTHON
resources/pkgs/32kb.data # original data (Perfect)
resources/pkgs/32kb.bpkg # current using bpkg file(feel free to modify)
resouces/pkgs/32kb_original.bpkg # original metadata (perfect)
32kb.data

```



# eeee

```C
struct bpkg_obj* bpkg_load(const char* path) {

char buffer[1025];

struct bpkg_obj* obj = NULL;

FILE* file = fopen(path, "r");

if (!file) {

fprintf(stderr, "Error opening file\n");

return NULL;

}

  

obj = malloc(sizeof(struct bpkg_obj));

if (!obj) {

fclose(file);

return NULL;

}

  

memset(obj, 0, sizeof(struct bpkg_obj));

  

if (fscanf(file, "ident:%1024s\n", obj->ident) != 1) {

fprintf(stderr, "Failed to read ident\n");

free(obj);

fclose(file);

return NULL;

}

  

if (fscanf(file, "filename:%256s\n", obj->filename) != 1) {

fprintf(stderr, "Failed to read filename\n");

free(obj);

fclose(file);

return NULL;

}

  

if (fscanf(file, "size:%u\n", &obj->size) != 1) {

fprintf(stderr, "Failed to read size\n");

free(obj);

fclose(file);

return NULL;

}

  
  

if(fscanf(file, "nhashes:%u\n", &obj->nhashes) == 1){

obj->hashes = malloc(obj->nhashes * sizeof(char*));

  

fgets(buffer, sizeof(buffer), file);// IGNORE 1 line

  

for (unsigned int i = 0; i < obj->nhashes; i++) {

obj->hashes[i] = malloc(65 * sizeof(char));

fscanf(file, "\t%64s\n", obj->hashes[i]);

}

}else{

fprintf(stderr, "Failed to read nhashes\n");

free(obj);

fclose(file);

return NULL;

}

  

if(fscanf(file, "nchunks:%u\n", &obj->nchunks) == 1){

fgets(buffer, sizeof(buffer), file);

obj->chunks = malloc(obj->nchunks * sizeof(struct bpkg_chunk));

  

for (unsigned int i = 0; i < obj->nchunks; i++) {

fscanf(file, "\t%64s,%u,%u\n", obj->chunks[i].hash,

&obj->chunks[i].offset, &obj->chunks[i].size);

}

}

  

fclose(file);

return obj;

}
```